package unionfind

// Weight union find with path compression. Be careful at finding the final results.
// If two nodes in initial have the same color (ie., belong to the same component), then
// removing them from initial won't decrease M(initial). This is because the malware will
// spread to reach every node in this component no matter what. So, among nodes with a unique
// color in initial, we will remove the node with the largest component size. (If there's
// a tie, we return the smallest index. Also, if there aren't any nodes with a unique color,
// we'll just return the smallest index node.)
// There is a DFS solution. Please refer to this link:
// https://leetcode.com/problems/minimize-malware-spread/solution/
// Time: O(n*n) - n is the length of the graph
// Space: O(n)
func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	parents := make([]int, n)
	size := make([]int, n)
	for i := 0; i < n; i++ {
		parents[i] = i
		size[i] = 1
	}
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			if graph[i][j] == 1 {
				// union
				union(parents, size, i, j)
			}
		}
	}
	count := make([]int, n)
	for _, init := range initial {
		count[find(parents, init)]++
	}
	res, curSize := -1, -1
	for _, init := range initial {
		root := find(parents, init)
		if count[root] == 1 {
			if size[root] > curSize || (size[root] == curSize && init < res) {
				res = init
				curSize = size[root]
			}
		}
	}
	if res == -1 {
		res = initial[0]
		for _, init := range initial {
			if init < res {
				res = init
			}
		}
	}
	return res
}

func union(parents, size []int, i, j int) {
	rootI := find(parents, i)
	rootJ := find(parents, j)
	if size[rootI] < size[rootJ] {
		parents[rootI] = rootJ
		size[rootJ] += size[rootI]
	} else {
		parents[rootJ] = rootI
		size[rootI] += size[rootJ]
	}
}

func find(parents []int, i int) int {
	if parents[i] != i {
		parents[i] = find(parents, parents[i])
	}
	return parents[i]
}
